**rvalue**# Memory Management

## Overview of Memory Types

### Cache
![Cache](/images/cache_levels.png)

#### L1 Cache
- Fastest and smallest memory type, usually in 16 - 64 kB range
- Separated into **instruction** (L1i) and **data** (L1d)
- grows in importance with increased speed of CPU
- *Avoids delays in data transmission and helps to make optimum use of CPU's capacity.*

#### L2 Cache
- located close to the CPU and has direct connection
- information between L2 and CPU is managed by L2 controller
- size usually < 2 MB
- Choosing between a processor with more clock speed or a larger L2 cache
    - higher clock speed => individual programs run faster
    - larger cache => several programs run simultaneously

#### L3 Cache
- Shared amongst all cores (multicore processor)
- [Cache Coherence Protocol (CCP)](https://en.wikipedia.org/wiki/Cache_coherence) can run much faster
   - Compares cache of all cores to maintain data consistency so everyone has access to all the data at the same time
- Intended to simplify and accelerate the CCP and data exchange between cores

### Temporal & Spacial Locality
Rough overview of the latency of various memory operations. Values might change based on system but the order of magnitude will be similar.
![Cache Locality](/images/cache_locality.png)
Originally from Peter Norvig: http://norvig.com/21-days.html#answers

#### Temporal Locality
- Over time the same memory address is accessed frequently (eg. in a loop)
- Keeps memory areas accessible as quickly as possible

#### Spatial Locality
- After an access to an address range, the next access to an address in the immediate vicinity is highly probable (e.g. in arrays)
- exploited by moving the adjacent address areas upwards into the next hierarchy level during a memory access.

```C++
#include <chrono>
#include <iostream>

int main()
{
    // create array
    const int size = 4;
    static int x[size][size];

    auto t1 = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < size; i++)
    {
        for (int j = 0; j < size; j++)
        {
            x[j][i] = i + j;
            std::cout << &x[j][i] << ": i=" << i << ", j=" << j << std::endl;
        }
    }

    // print execution time to console
    auto t2 = std::chrono::high_resolution_clock::now(); // stop time measurement
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(t2 - t1).count();
    std::cout << "Execution time: " << duration << " microseconds" << std::endl;

    return 0;
}
```
Code example provided by: Udacity C++ Nanodegree

#### Commands to Try
```bash
# MAC OS
sysctl -a hw

# Debian Linux
lscpu | grep Cache
```

### Virtual Memory
- Virtual memory is a very useful concept in computer architecture because it helps with making your software work well given the configuration of the respective hardware on the computer it is running on.
- In a nutshell, virtual memory guarantees us a fixed-size address space which is largely independent of the system configuration. Also, the OS guarantees that the virtual address spaces of different programs do not interfere with each other.
- The task of mapping addresses and of providing each program with its own virtual address space is performed entirely by the operating system, so from a programmer’s perspective, we usually don’t have to bother much about memory that is being used by other processes.
- Two important terms which are often used in the context of caches and virtual memory:
   - Memory Page: number of successive memory locations in a virtual memory defined by the computer architecture and the OS.
   - Memory Frame: Same as memory page but is located in the physical memory space and **NOT** the virtual memory space.
   ![Virtual Memory](/images/virtual_memory.png)
   Image by *Udacity C++ Nanodegree*

   As can be seen, both processes have their own virtual memory space. Some of the pages are mapped to frames in the physical memory and some are not. If process 1 needs to use memory in the memory page that starts at address 0x1000, a page fault will occur if the required data is not there. The memory page will then be mapped to a vacant memory frame in physical memory. Also, note that the virtual memory addresses are not the same as the physical addresses. The first memory page of process 1, which starts at the virtual address 0x0000, is mapped to a memory frame that starts at the physical address 0x2000.

   > Relocating virtual swap file to a SSD Location would help with performance.

## Variables and Memory
### The Process Memory Model
![Process Model](/images/virtual_process_model.png)
Image by *Udacity C++ Nanodegree*

We are unable to use the entire address space.
- Non-usable blocks
  - OS Kernel Space and Text are reserved for the OS
    - In **kernel space** only code trusted is executed, maintained by the OS & serves as an interface between the user code and system kernel
    - In **text space** holds code generated by the compiler and linker
- Usable blocks
  - **stack**: a contiguous memory block of fixed size ([see code example stackOverflow.cpp](stackOverflow.cpp))
  - **heap**: memory space where data with dynamic storage lives
  - **Block Started by Symbol (BSS)**: used in many compilers and linkers, contains global and static variables that are initialized with zero values i.e. arrays that are not initialized with predefined values
  - Memory for variables in segment is allocated once when a program is run and persists through its lifetime
  - **Data**: this segments is similar to *BSS* with major difference being that variables in this segment have non-zero initialized values.
  - Memory for variables in segment is allocated once when a program is run and persists through its lifetime


  | STACK MEMORY | HEAP MEMORY |
  | :---: | :---: |
  | automatically allocated | dynamically allocated |
  | fixed memory size | theoretically no size limitations (limited by available memory) |
  | variables are allocated at compile-time | variables are allocated at run-time |
  | stores local variables & function inputs/outputs | |
  | very efficient since managed by OS | computationally more expensive than stack |
  | OS automatically manages memory | programmer has to manage memory using *malloc/free* or *new/delete* |
  | thread-safe, each thread has dedicated stack | shared between threads, need to account for concurrency |
  | limited scope based on entry/exit | scope available until address is known |
  | stack memory is sequential therefore easy and secure | heap allocation/deallocations can occur arbitrarily therefore memory is fragmented overtime making it more difficult and expensive to manage. |
  > - Decision between stack and heap comes down to application. Based on the application programmer must pick the best suited space and know the advantages & disadvantages.
  > - By default **stack** should be the choice of memory since access is usually faster making memory management easier than the heap but has limited space and variables will only get deallocated when out of scope
  > - **heap** is better suited when large memory storage is required i.e. images/videos etc. However, programmer needs to carefully manage memory, if not managed correctly it can lead to memory leaks or dangling pointers.

### Memory Allocation C++
- Types of memory Allocation
  - Static Memory Allocation
    - performed for static and global variables
    - memory persists for lifetime of program
  - Automatic Memory Allocation
    - performed for functions parameters and local variables
    - stored on the **stack**
    - limited scope based on enter/exit
  - Dynamic Memory Allocation
    - way for programs to request memory from the OS at runtime as needed
    - performed on the **heap** and only limited by the size of the address space

## Dynamic Memory Allocation (The Heap)
### Using malloc and free
**Allocating Dynamic Memory on the heap**
There are two ways of allocating contiguous block of memory on the heap. *If the space is insufficient, returns NULL pointer.*
1. ```malloc``` is used to dynamically allocate a single large block of memory
```C++
pointer_name = (cast-type*) malloc(size);
```
2. ```calloc``` is used to dynamically allocate the specified number of blocks of memory of the specified type. Each block is initialized to zero.
```C++
pointer_name = (cast-type*) calloc(num_elems, size_elems);
```
3. ```realloc``` can be used to grow memory size without overwriting data
```C++
pointer_name = (cast-type*) realloc(pointer_name, new_size);
```
4. ```free``` is used to free up allocated memory ```free(pointer_name)```
  - can only release memory that was reserved by ```malloc``` or ```calloc```
  - can only release memory that hasn't been released before. Releasing same block of memory twice will result in error.

### Using new and delete
- ```new/delete are operators``` while ```malloc/calloc/realloc/free are functions``` this allows operator overloading for ```new/delete```
- new/delete are the object-oriented counterpart to memory management with malloc/free
#### Major differences between malloc/free and new/delete
- new/delete call the constructor/destructor while malloc/free don't
- ```malloc``` returns a ```void``` which needs to be type -casted
```C++
// Malloc example
MyObject *p_malloc = (MyObject*)malloc(sizeof(int));
// cleanup of memory allocated using "malloc"
free(p_malloc);
// "new" syntax - returns correct type automatically - it is type-safe
MyObject *p_new = new MyObject();
// cleanup of memory allocated using "new"
delete p_new;
```
##### Optimizing Performance with placement new
Separating allocation from construction can significantly improve performance. This can be done using ```placement new``` syntax as follows
```C++
void *memory = malloc(size of MyClass));
MyClass *object = new (memory); // placement new
MyClass;
//deleting "placement new" memory
object->~MyClass();
free(memory);
```
##### Reasons for overloading ```new``` and ```delete```
1. Overloaded new operator functions allows to add additional parameters giving programmer more flexibility in customizing the memory allocation for objects.
2. Provides an easy way to integrate a mechanism similar to garbage collections (such as java)
3. Code can be made more robust by adding exception handling capabilities into ```new/delete```
4. It is easy to add customized behavior, ex. overwriting deallocated memory with zeros to improve security of critical application data

### Typical Memory management problems
| Operating System | Debugging Tools | Example command |
| :--- | :--- | :--- |
| Linux/MacOS | [Valgrind](https://valgrind.org/) | ```valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose --log-file=./bin/valgrind-out.txt <cpp_executable_filename>``` |
| Windows | [Visual Studio](https://visualstudio.microsoft.com/downloads/) and [C Run-time Library (CRT)](https://learn.microsoft.com/en-us/visualstudio/debugger/finding-memory-leaks-using-the-crt-library?view=vs-2019) | |

1. Memory leaks
  - occur when data is allocated in the heap at runtime but not properly deallocated.
  - program that forgets to clear a memory block is said to have a memory leaks
  - if a program runs for a short time, memory leaks are not a significant problem
  - memory leaks are a problem when a program has a long runtime or uses a large data structure, this can fill the heap causing a program crash
2. Buffer overruns
  - occur when memory outside the allocated limits is overwritten.
  - this effect may not be visible immediately
  - sometimes leads to injecting malicious code into program
3. Uninitialized memory
  - based on the compiler data structures sometimes are not initialized, this can cause issues since there might be garbage values in that memory location
  - Generally variable will be automatically initialized if
    - the default constructor initializes all primitive types
    - array initializer syntax is used int ```a[10] = {};```
    - it is a global or extern variable
    - it is defined as ```static```
4. Incorrect pairing of allocation and deallocation
  - freeing block of memory more than once
  - freeing block of memory that has not been allocated
  - using ```malloc() & delete``` or ```new & free()``` can also cause improper pairings
5. Invalid Memory Access
  - Occurs when trying to access a block of heap memory that has not yet or has been deallocated

## Resource Copying Policies
### Copy semantics
- Default assignment operator creates a duplicate copy of all the member variables inside the object
- Default behavior of both the ```copy constructor``` and ```assignment operator``` is to perform a **shallow copy**
  |![Shallow Copy](/images/resourceCopy_shallowCopy.png) |![Deep Copy](/images/resourceCopy_deepCopy.png) |
  | :---: | :---: |

- Different Copy Policies
  1. Default copying (a.k.a Shallow Copy)
  2. No Copying
  3. Exclusive ownership
  4. Deep copying
  5. Shared Ownership

#### Default Copy - Copy Semantics Code provided by Udacity C++ Nanodegree
<details open>
  <summary style="color:MediumSeaGreen;font-size:80%;"><b>Sample Code - Exclusive Ownership</b></summary>

```C++
#include <iostream>

class MyClass
{
private:
    int *_myInt;
public:
    MyClass()
    {
        _myInt = (int *)malloc(sizeof(int));
    };
    ~MyClass()
    {
        free(_myInt);
    };
    void printOwnAddress() { std::cout << "Own address on the stack is " << this << std::endl; }
    void printMemberAddress() { std::cout << "Managing memory block on the heap at " << _myInt << std::endl; }
};
int main()
{
    // instantiate object 1
    MyClass myClass1;
    myClass1.printOwnAddress();
    myClass1.printMemberAddress();

    // copy object 1 into object 2
    MyClass myClass2(myClass1); // default copy constructor - shallow copy
    myClass2.printOwnAddress();
    myClass2.printMemberAddress();

    return 0;
}
```
</details>

#### NoCopy Policy - Copy Semantics Code provided by Udacity C++ Nanodegree
- This is the simplest policy in which all copying and assignment is forbidden.
- This is achieved by declaring but not defining a private copy constructor (see ```NoCopyClass1```) and assignment operator or alternatively by making both public and assigning the ```delete``` operator (see ```NoCopyClass2```).
- On compiling the code will generate an error which indicates that both cases effectively prevent the original object from being copied/assigned.

<details open>
  <summary style="color:MediumSeaGreen;font-size:80%;"><b>Sample Code - No Policy</b></summary>

  ```C++
  class NoCopyClass1
  {
  private:
      NoCopyClass1(const NoCopyClass1 &);
      NoCopyClass1 &operator=(const NoCopyClass1 &);

  public:
      NoCopyClass1(){};
  };
  class NoCopyClass2
  {
  public:
      NoCopyClass2(){}
      NoCopyClass2(const NoCopyClass2 &) = delete;
      NoCopyClass2 &operator=(const NoCopyClass2 &) = delete;
  };
  int main()
  {
      NoCopyClass1 original1;
      NoCopyClass1 copy1a(original1); // copy c’tor
      NoCopyClass1 copy1b = original1; // assigment operator

      NoCopyClass2 original2;
      NoCopyClass2 copy2a(original2); // copy c’tor
      NoCopyClass2 copy2b = original2; // assigment operator

      return 0;
  }
  ```

</details>

#### Exclusive Ownership - Copy Semantics Code provided by Udacity C++ Nanodegree
- This policy states that whenever a resource management object is copied, the resource handle is transferred from the **source pointer** to the **destination pointer** and the **source pointer** is set to ```null```
- The resource handle belongs to only one single object at any time

<details open>
  <summary style="color:MediumSeaGreen;font-size:80%;"><b>Sample Code - Exclusive Ownership</b></summary>

  ```C++
  #include <iostream>

  class ExclusiveCopy
  {
  private:
      int *_myInt;

  public:
      ExclusiveCopy()
      {
          _myInt = (int *)malloc(sizeof(int));
          std::cout << "resource allocated" << std::endl;
      }
      ~ExclusiveCopy()
      {
          if (_myInt != nullptr)
          {
              free(_myInt);
              std::cout << "resource freed" << std::endl;
          }

      }
      ExclusiveCopy(ExclusiveCopy &source)
      {
          _myInt = source._myInt;
          source._myInt = nullptr;
      }
      ExclusiveCopy &operator=(ExclusiveCopy &source)
      {
          _myInt = source._myInt;
          source._myInt = nullptr;
          return *this;
      }
  };

  int main()
  {
      ExclusiveCopy source;
      ExclusiveCopy destination(source);

      return 0;
  }
  ```

</details>

#### Deep Copying - Copy Semantics Code provided by Udacity C++ Nanodegree
- This policy ensures that copying and assigning class instances to each other can be done without the danger of resource conflicts.
- Proprietary memory is allocated in the destination object and then copy the content of the source into the allocated memory block
- This approach increases memory demands, after a deep copy two versions of the same resource exist in memory.

<details open>
  <summary style="color:MediumSeaGreen;font-size:80%;"><b>Sample Code - Deep Copying</b></summary>

  ```C++
  #include <iostream>

  class DeepCopy
  {
  private:
      int *_myInt;

  public:
      DeepCopy(int val)
      {
          _myInt = (int *)malloc(sizeof(int));
          *_myInt = val;
          std::cout << "resource allocated at address " << _myInt << " with _myInt = " << *_myInt << std::endl;
      }
      ~DeepCopy()
      {
          free(_myInt);
          std::cout << "resource freed at address " << _myInt << std::endl;
      }
      DeepCopy(DeepCopy &source)
      {
          _myInt = (int *)malloc(sizeof(int));
          *_myInt = *source._myInt;
          std::cout << "resource allocated at address " << _myInt << " with _myInt = " << *_myInt << std::endl;
      }
      DeepCopy &operator=(DeepCopy &source)
      {
          _myInt = (int *)malloc(sizeof(int));
          std::cout << "resource allocated at address " << _myInt << " with _myInt=" << *_myInt << std::endl;
          *_myInt = *source._myInt;
          return *this;
      }
  };

  int main()
  {
      DeepCopy source(42);
      DeepCopy dest1(source);
      DeepCopy dest2 = dest1;

      return 0;
  }

  ```
</details>

#### Shared Ownership - Copy Semantics Code provided by Udacity C++ Nanodegree
- This policy type performs a copy or assignment similar to the default behavior while at the same time keeping track of the number of instances that point to the object.
- Each time an instance goes out of scope, the counter is decremented.
- The memory is freed only when the last object is about to be deleted.
- **NOTE**: the class SharedCopy does not implement the assignment operator. This is a violation of the **Rule of Three** (see below) and thus, if we were to use something like ```destination3 = source``` instead of ```SharedCopy destination3(source)```, the counter variable would not be properly decremented.
<details open>
  <summary style="color:MediumSeaGreen;font-size:80%;"><b>Sample Code - Shared Ownership</b></summary>

  ```C++
  #include <iostream>

  class SharedCopy
  {
  private:
      int *_myInt;
      static int _cnt;

  public:
      SharedCopy(int val);
      ~SharedCopy();
      SharedCopy(SharedCopy &source);
  };

  int SharedCopy::_cnt = 0;

  SharedCopy::SharedCopy(int val)
  {
      _myInt = (int *)malloc(sizeof(int));
      *_myInt = val;
      ++_cnt;
      std::cout << "resource allocated at address " << _myInt << std::endl;
  }

  SharedCopy::~SharedCopy()
  {
      --_cnt;
      if (_cnt == 0)
      {
          free(_myInt);
          std::cout << "resource freed at address " << _myInt << std::endl;
      }
      else
      {
          std::cout << "instance at address " << this << " goes out of scope with _cnt = " << _cnt << std::endl;
      }
  }

  SharedCopy::SharedCopy(SharedCopy &source)
  {
      _myInt = source._myInt;
      ++_cnt;
      std::cout << _cnt << " instances with handles to address " << _myInt << " with _myInt = " << *_myInt << std::endl;
  }

  int main()
  {
      SharedCopy source(42);
      SharedCopy destination1(source);
      SharedCopy destination2(source);
      SharedCopy destination3(source);

      return 0;
  }
  ```
</details>

#### Rule of Three
This rule states that if a class needs to have an overloaded ```copy constructor``` ```copy assignment operator``` or ```destructor``` then it must also implement the other two

### Lvalues and Rvalues
#### lvalues
- **Lvalues** have an address that can be accessed. They are expressions whose evaluation by the compiler determines the identity of objects or functions.
  - In more general terms, **lvalue** is an entity that points to a specific memory location.
  - one could think of lvalues as named containers for **rvalues**.
- One of the primary use-cases for **lvalue** references is the pass-by-reference semantics in function calls
#### rvalues
- **prvalues** do not have an address that is accessible directly. They are temporary expressions used to initialize objects or compute the value of the operand of an operator. For the sake of simplicity and for compliance with many tutorials, videos and books about the topic, let us refer to **prvalues** as **rvalues** from here on.
  - An **rvalue** is usually a short-lived object, which is only needed in a narrow local scope.
- Since C++11, there is a new type available called rvalue reference, which can be identified from the double ampersand && after a type name. With this operator, it is possible to store and even modify an rvalue, i.e. a temporary object which would otherwise be lost quickly.

  ```C++
  #include <iostream>

  int main()
  {
      int i = 1;
      int j = 2;
      int k = i + j;
      int &&l = i + j;

      std::cout << "k = " << k << ", l = " << l << std::endl;

      return 0;
  }
  ```
    - One of the most important aspects of rvalue references is that they pave the way for move semantics, which is a mighty technique in modern C++ to optimize memory usage and processing speed.
#### External references
  - [How to crack the confusing world of lvalues and rvalues in C++? It is easy!](https://medium.com/@dhaneshvb/how-to-crack-the-confusing-world-of-lvalues-and-rvalues-in-c-it-is-easy-61c32ced51ce)
  - [Lvalues and Rvalues (C++)](https://docs.microsoft.com/en-us/cpp/cpp/lvalues-and-rvalues-visual-cpp?view=msvc-160)

### Move semantics
- The basic idea to optimize the code from the last example is to "steal" the rvalue generated by the compiler during the return-by-value operation and move the expensive data in the source object to the target object - not by copying it but by redirecting the data handles. Moving data in such a way is always cheaper than making copies, which is why programmers are highly encouraged to make use of this powerful tool.
  <br></br>
  <img src="/images/moveSemantics.png" width="400">

<details open>
  <summary style="color:MediumSeaGreen;font-size:80%;"><b>Example of move constructor and move operator=</b></summary>

  ```C++
  #include <stdlib.h>
  #include <iostream>

  class MyMovableClass
  {
  private:
      int _size;
      int *_data;

  public:
      MyMovableClass(size_t size) // constructor
      {
          _size = size;
          _data = new int[_size];
          std::cout << "CREATING instance of MyMovableClass at " << this << " allocated with size = " << _size*sizeof(int)  << " bytes" << std::endl;
      }

      ~MyMovableClass() // 1 : destructor
      {
          std::cout << "DELETING instance of MyMovableClass at " << this << std::endl;
          delete[] _data;
      }

      MyMovableClass(const MyMovableClass &source) // 2 : copy constructor
      {
          _size = source._size;
          _data = new int[_size];
          *_data = *source._data;
          std::cout << "COPYING content of instance " << &source << " to instance " << this << std::endl;
      }

      MyMovableClass &operator=(const MyMovableClass &source) // 3 : copy assignment operator
      {
          std::cout << "ASSIGNING content of instance " << &source << " to instance " << this << std::endl;
          if (this == &source)
              return *this;
          delete[] _data;
          _data = new int[source._size];
          *_data = *source._data;
          _size = source._size;
          return *this;
      }

      MyMovableClass(MyMovableClass &&source) // 4 : move constructor
      {
          std::cout << "MOVING (c’tor) instance " << &source << " to instance " << this << std::endl;
          _data = source._data;
          _size = source._size;
          source._data = nullptr;
          source._size = 0;
      }

      MyMovableClass &operator=(MyMovableClass &&source) // 5 : move assignment operator
      {
          std::cout << "MOVING (assign) instance " << &source << " to instance " << this << std::endl;
          if (this == &source)
              return *this;

          delete[] _data;

          _data = source._data;
          _size = source._size;

          source._data = nullptr;
          source._size = 0;

          return *this;
      }
  };

  int main()
  {
      MyMovableClass obj1(10); // regular constructor
      MyMovableClass obj2(obj1); // copy constructor
      obj2 = obj1; // copy assignment operator

      return 0;
  }
  ```
</details>

##### Rule of Five
- The Rule of Five states that if you have to write one of the functions listed below then you should consider implementing all of them with a proper resource management policy in place. If you forget to implement one or more, the compiler will usually generate the missing ones (without a warning) but the default versions might not be suitable for the purpose you have in mind. The five functions are:
  1. The destructor: Responsible for freeing the resource once the object it belongs to goes out of scope.
  2. The assignment operator: The default assignment operation performs a member-wise shallow copy, which does not copy the content behind the resource handle. If a deep copy is needed, it has be implemented by the programmer.
  3. The copy constructor: As with the assignment operator, the default copy constructor performs a shallow copy of the data members. If something else is needed, the programmer has to implement it accordingly.
  4. The move constructor: Because copying objects can be an expensive operation which involves creating, copying and destroying temporary objects, rvalue references are used to bind to an rvalue. Using this mechanism, the move constructor transfers the ownership of a resource from a (temporary) rvalue object to a permanent lvalue object.
  5. The move assignment operator: With this operator, ownership of a resource can be transferred from one object to another. The internal behavior is very similar to the move constructor.

## Smart Pointers
### Resource Acquisition is Initialization (RAII)

<style>
img {
  border: 2px solid #000;
}
</style>
<img src="/images/raii.png" width="400">

The technique of wrapping a management class around a resource is called Resource Acquisition Is Initialization (RAII).

- RAII can be used to leverage - among others - the following advantages:
  - Use class destructors to perform resource clean-up tasks such as proper memory deallocation when the RAII object gets out of scope
  - Manage ownership and lifetime of dynamically allocated objects
  - Implement encapsulation and information hiding due to resource acquisition and release being performed within the same object.
- RAII from the perspective of memory management
  - A resource is allocated in the constructor of the RAII class
  - The resource is deallocated in the destructor
  - All instances of the RAII class are allocated on the stack to reliably control the lifetime via the object scope

<details open>
  <summary style="color:MediumSeaGreen;font-size:80%;">
  <b>RAII Code Example: Shows that we successfully used the RAII idiom to create a memory management class that spares us from thinking about calling delete. By creating the </b><code>MyInt</code> <b>object on the stack, we ensure that the deallocation occurs as soon as the object goes out of scope. </b></summary>

  ```C++
  #include <iostream>

  class MyInt
  {
      int *_p; // pointer to heap data
  public:
      MyInt(int *p = NULL) { _p = p; }
      ~MyInt()
      {
          std::cout << "resource " << *_p << " deallocated" << std::endl;
          delete _p;
      }
      int &operator*() { return *_p; } // // overload dereferencing operator
  };

  int main()
  {
      double den[] = {1.0, 2.0, 3.0, 4.0, 5.0};
      for (size_t i = 0; i < 5; ++i)
      {
          // allocate the resource on the stack
          MyInt en(new int(i));

          // use the resource
          std::cout << *en << "/" << den[i] << " = " << *en / den[i] << std::endl;
      }

      return 0;
  }
  ```
</details>

### Smart Pointers
- C++11 has introduced three types of smart pointers, which are defined in the header of the standard library:
  1. The unique pointer ```std::unique_ptr```
    - smart pointer which exclusively owns a dynamically allocated resource on the heap.
    - There must not be a second unique pointer to the same resource.
    - **useful** when working with a temporary heap resource that is no longer needed once it goes out of scope.
  2. The shared pointer ```std::shared_ptr```
    - points to a heap resource but does not explicitly own it.
    - There may even be several shared pointers to the same resource
      - each of which will increase an internal reference count.
      - As soon as this count reaches zero, the resource will automatically be deallocated.
    - **useful** for cases where you require access to a memory location on the heap in multiple parts of your program and you want to make sure that whoever owns a shared pointer to the memory can rely on the fact that it will be accessible throughout the lifetime of that pointer.
    - Shared pointers can get into a **Deadlock** state. This is when there is some type of circular dependency between objects that prevents them from being cleaned up correctly. See code example below.
      <details open>
        <summary style="color:MediumSeaGreen;font-size:80%;">
        <b>Deadlock state: </b><code>myClass1->_member = myClass2</code><b> increments the ref count (same with the </b><code>myClass2->_member = myClass1</code><b>) causing a memory leak since the destructor is not called. When <code>myClass1</code> goes out of scope in main, its destructor can’t clean up memory as there is still a reference count of 1 in the smart pointer, which is caused by the shared pointer _member in <code>myClass2</code>. To avoid this </b><code>std::weak_ptr</code><b> is used instead.</b></summary>

        ```C++
        #include <iostream>
        #include <memory>

        class MyClass
        {
        public:
            std::shared_ptr<MyClass> _member;
            ~MyClass() { std::cout << "Destructor of MyClass called" << std::endl; }
        };

        int main()
        {
            std::shared_ptr<MyClass> myClass1(new MyClass);
            std::shared_ptr<MyClass> myClass2(new MyClass);

            // These two lines produce a circular reference
            myClass1->_member = myClass2;
            myClass2->_member = myClass1;

            return 0;
        }
        ```
      </details>
  3. The weak pointer ```std::weak_ptr```
    - behaves similar to the shared pointer but does not increase the reference counter.
    - hold a non-owning reference to an object that is managed by another shared pointer.
    - You can only create weak pointers out of shared pointers or out of another weak pointer.

  <table>
  <tr>
  <td> Image </td> <td> Sample Code </td>
  </tr>
  <tr>
  <td> <img src="/images/smartPtr_uniquePtr.png" width="400"> </td>
  <td>

  ```C++
  #include <memory>

  void RawPointer()
  {
      int *raw = new int; // create a raw pointer on the heap
      *raw = 1; // assign a value
      delete raw; // delete the resource again
  }

  void UniquePointer()
  {
      std::unique_ptr<int> unique(new int); // create a unique pointer on the stack
      *unique = 2; // assign a value
      // delete is not necessary
  }
  ```
  </td>
  <tr>
  <td> <img src="/images/smartPtr_sharedPtr.png" width="400"> </td>
  <td>

  ```C++
  #include <iostream>
  #include <memory>

  class MyClass
  {
  public:
      ~MyClass() { std::cout << "Destructor of MyClass called" << std::endl; }
  };

  int main()
  {
      std::shared_ptr<int> shared1(new int);
      std::cout << "shared pointer count = " << shared1.use_count() << std::endl;

      {
          std::shared_ptr<int> shared2 = shared1;
          std::cout << "shared pointer count = " << shared1.use_count() << std::endl;
      }

      std::cout << "shared pointer count = " << shared1.use_count() << std::endl;

      std::shared_ptr<MyClass> shared(new MyClass);
      std::cout << "shared pointer count = " << shared.use_count() << std::endl;

      shared.reset(new MyClass);
      std::cout << "shared pointer count = " << shared.use_count() << std::endl;

      return 0;
  }
  ```
  </td>
  </tr>
  <tr>
  <td> <img src="/images/smartPtr_weakPtr.png" width="400"> </td>
  <td>

  ```C++
  #include <iostream>
  #include <memory>

  int main()
  {
      std::shared_ptr<int> mySharedPtr(new int);
      std::cout << "shared pointer count = " << mySharedPtr.use_count() << std::endl;

      std::weak_ptr<int> myWeakPtr1(mySharedPtr);
      std::weak_ptr<int> myWeakPtr2(myWeakPtr1);
      std::cout << "shared pointer count = " << mySharedPtr.use_count() << std::endl;

      // std::weak_ptr<int> myWeakPtr3(new int); // COMPILE ERROR

      return 0;
  }
  ```

  Checking validity of a weak pointer.
  ```C++
  #include <iostream>
  #include <memory>

  int main()
  {
      std::shared_ptr<int> mySharedPtr(new int);
      std::weak_ptr<int> myWeakPtr(mySharedPtr);

      mySharedPtr.reset(new int);

      if (myWeakPtr.expired() == true)
      {
          std::cout << "Weak pointer expired!" << std::endl;
      }

      return 0;
  }
  ```
  </td>
  </tr>
  </table>

### Transferring ownership
### Importance of Scope
